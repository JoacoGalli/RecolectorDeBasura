# -*- coding: utf-8 -*-
"""buffer.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qwSsss8_37XUVky8bwZB2tnuaCMNIrMx

# Inicialización
"""

# from pydrive.auth import GoogleAuth
# from pydrive.drive import GoogleDrive
# from google.colab import auth
# from oauth2client.client import GoogleCredentials

import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.image as img

import numpy as np
from scipy import ndimage as ndi
import random

from skimage.color import rgba2rgb
from skimage.color import rgb2gray
from skimage.filters import gabor_kernel

# !pip install hilbertcurve # IPython command para jupyter google colab
from hilbertcurve.hilbertcurve import HilbertCurve

from tqdm import tqdm

import os

# Buscamos los archivos en la carpeta compartida
# auth.authenticate_user()
# gauth = GoogleAuth()
# gauth.credentials = GoogleCredentials.get_application_default()
# drive = GoogleDrive(gauth)

# file_acumar = drive.CreateFile({'id':'1HowdvZ70LubP5u2gpNY1YimIcFr03wrj'}) # los links están actualizados
# file_acumar.GetContentFile('basura_000.png')
img_acumar = img.imread('../../../proyecto/mediciones/fotos_buffer/otros/buffer_tapas_plasticas_verde.png')

# file_buffer = drive.CreateFile({'id':'1pbKwsFAAQdQXWaddtCK7OccS87Rr3N_L'}) # los links están actualizados
# file_buffer.GetContentFile('buffer_000.png')
img_buffer_acumar = img.imread("../../../proyecto/mediciones/fotos_buffer/buffer_vacio_negro.png")

# dpi de la imagen para imprimir en pantalla
mpl.rcParams['figure.dpi'] = 300

"""# Imágenes

Si se quiere realizar pruebas con todas las imágenes, copiar la carpeta que está en este [link](https://drive.google.com/drive/folders/1hMlQEZMYlxg4wqgqZuHyVG8o-Ca8-MmW?usp=sharing) en la unidad de drive dejando el mismo nombre y descomentar la siguiente celda
"""

# from google.colab import drive
# drive.mount('/content/gdrive')

# # Imágenes reales
# def get_filepaths(directory):
#     file_paths = []
#     for root, directories, files in os.walk(directory):
#         for filename in files:
#             filepath = os.path.join(root, filename)
#             file_paths.append(filepath)

#     return file_paths

# images_dir = '/content/gdrive/My Drive/Imagenes_buffer'
# filenames = get_filepaths(images_dir)

# path = os.getcwd()
# files = os.listdir(path)
# filenames = [f for f in files if (f[-3:] == 'png') | (f[-3:] == 'jpg')]
# filenames.sort()
# img_files = []
# for i in range(len(filenames)):
#     img_files.append(img.imread(filenames[i]))

# img_source = img_files[1]
# img_buffer = img_files[2]

# img_total_number = len(img_source)
# print(img_total_number)
"""# Funciones

## Inicializar curvas de Hilbert
"""

hilbert_curves = []
hilbert_curves_points = []
hilbert_curves.append([])
hilbert_curves_points.append([])
n_hil = 2

for p_hil in range(1, 12): # resolución máxima 4K
    hilbert_curves.append(HilbertCurve(p_hil, n_hil))
    hilbert_curves_points.append(hilbert_curves[p_hil].points_from_distances(range(1, (n_hil**p_hil)**2)))

"""## Preprocesamiento"""

# Genera una imagen a partir del filtro de gabor y una imagen en escala de grises
def gabor_img(img, kernel):
    img = (img - img.mean())/img.std() # normaliza la imagen
    return np.sqrt(ndi.convolve(img, np.real(kernel), mode='wrap')**2 +
                   ndi.convolve(img, np.imag(kernel), mode='wrap')**2)

# Genera una imagen a partir de la curva de Hilbert y una imagen en escala de grises
def hilbert_img(img, edge_thr = 0.05):
    max_dim = np.max(img.shape[:2])
    n_hil = 2
    p_hil = np.ceil(np.log2(max_dim)).astype(int)
    square_size = n_hil**p_hil
    img_edge = np.ones((square_size, square_size))
    img_hilbert = np.zeros((square_size, square_size))

    previous_point = hilbert_curves_points[p_hil][0]
    for point in hilbert_curves_points[p_hil]:
        if point[0] < img.shape[0] and point[1] < img.shape[1]:
            img_hilbert[point[0], point[1]] = np.abs(img[point[0], point[1]] - img[previous_point[0], previous_point[1]])
            if(img_hilbert[point[0], point[1]] > edge_thr):
                img_edge[point[0], point[1]] = 0
            previous_point = point
    return img_edge[:img.shape[0], :img.shape[1]], 1 - img_hilbert[:img.shape[0], :img.shape[1]]

"""## Transformadas"""

# Genera una imagen en base a la entropía parcial de una imagen en escala de grises
def entropy_transform(img, img_buffer, kernel_size = 32, entropy_thr = 5, progress_bar = False):
    assert kernel_size <= img.shape[0] or kernel_size <= img.shape[1]

    kernel_half_size = int(np.ceil(kernel_size/2))

    img_tr = np.zeros(img.shape)
    img_entropy = np.zeros(img.shape)
    bins = np.histogramdd([0, 1], bins = 256)[1]

    if progress_bar:
        iterator = tqdm(range(img.shape[0] - kernel_size + 1))
    else:
        iterator = range(img.shape[0] - kernel_size + 1)

    for i in iterator:
        for j in range(img.shape[1] - kernel_size + 1):
            if img_buffer[i + kernel_half_size - 1, j + kernel_half_size - 1] > 0:
                img_kernel = img[i:i + kernel_size, j:j + kernel_size]
                img_buffer_kernel = img_buffer[i:i + kernel_size, j:j + kernel_size]
                img_kernel_limited = img_kernel[(img_buffer_kernel > 0)]
                density = np.histogramdd(np.ravel(img_kernel_limited), bins = bins)[0]/img_kernel_limited.size
                density = list(filter(lambda p: p > 0, np.ravel(density)))
                entropy = -np.sum(np.multiply(density, np.log2(density)))
                img_entropy[i + kernel_half_size - 1, j + kernel_half_size - 1] = entropy
                img_tr[i + kernel_half_size - 1, j + kernel_half_size - 1] = float(entropy > entropy_thr)

    return img_tr, img_entropy/8

# Genera una imagen en base a la media parcial de una imagen en escala de grises
def mean_transform(img, img_buffer, kernel_size = 32, mean_thr = 0.1, progress_bar = False):
    assert kernel_size <= img.shape[0] or kernel_size <= img.shape[1]

    kernel_half_size = int(np.ceil(kernel_size/2))

    img_tr = np.zeros(img.shape)
    img_mean = np.zeros(img.shape)

    if progress_bar:
        iterator = tqdm(range(img.shape[0] - kernel_half_size))
    else:
        iterator = range(img.shape[0] - kernel_half_size)

    for i in iterator:
        for j in range(img.shape[1] - kernel_half_size):
            if img_buffer[i + kernel_half_size - 1, j + kernel_half_size - 1] > 0:
                img_kernel = img[i:i + kernel_size, j:j + kernel_size]
                img_buffer_kernel = img_buffer[i:i + kernel_size, j:j + kernel_size]
                img_kernel_limited = img_kernel[(img_buffer_kernel > 0)]
                mean = np.mean(img_kernel_limited)
                img_mean[i + kernel_half_size - 1, j + kernel_half_size - 1] = mean
                img_tr[i + kernel_half_size - 1, j + kernel_half_size - 1] = float(mean < mean_thr)

    return img_tr, img_mean

"""## Contorno"""

# Marca el contorno de las imágenes binarias
def outline(img_bn, img_source, widen_n = 4, color = 1):
    assert color == 0 or color == 1 or color == 2
    img_bn_edge = hilbert_img(img_bn)[0]

    widen_img = img_bn_edge.copy()
    for it in range(widen_n):
        for i in range(1, img_bn_edge.shape[0] - 1):
            for j in range(1, img_bn_edge.shape[1] - 1):
                if img_bn_edge[i, j] == 0:
                    widen_img[i - 1, j] = 0
                    widen_img[i, j - 1] = 0
                    widen_img[i + 1, j] = 0
                    widen_img[i, j + 1] = 0
        img_bn_edge = widen_img.copy()

    if img_source.shape[2] == 4:
        outline_img = rgba2rgb(img_source)
    else:
        outline_img = img_source.copy()

    border_index = (img_bn_edge == 0).nonzero()
    outline_img[border_index[0], border_index[1], :] = 0
    outline_img[border_index[0], border_index[1], color] = 255 if np.max(outline_img) > 1 else 1

    return outline_img

"""## Funciones viejas

### Preprocesamiento
"""

# # Recorta una imagen para que sea cuadrada
# def square_img(img, square_size, offset_x = 0, offset_y = 0):
   
#     max_size = np.max([img.shape[1] + offset_x, square_size + offset_x, img.shape[0] + offset_y, square_size + offset_y])

#     if len(img.shape) == 3 and img.shape[2] > 1:
#         img_square = np.zeros((max_size, max_size, img.shape[2]))
#         img_type = type(img[0, 0, 0])
#     else:
#         img_square = np.zeros((max_size, max_size))
#         img_type = type(img[0, 0])   

#     img_square[:img.shape[0], :img.shape[1]] = img
#     assert offset_y + square_size <= img_square.shape[0] and offset_x + square_size <= img_square.shape[1]
#     return img_square[offset_y:offset_y + square_size, offset_x:offset_x + square_size].astype(img_type)


# # Genera una imagen a partir del filtro de gabor y una imagen en escala de grises
# def gabor_img(img, kernel):
#     img = (img - img.mean())/img.std() # normaliza la imagen
#     return np.sqrt(ndi.convolve(img, np.real(kernel), mode='wrap')**2 +
#                    ndi.convolve(img, np.imag(kernel), mode='wrap')**2)


# # Genera una imagen a partir de la curva de Hilbert y una imagen en escala de grises
# def hilbert_img(img, edge_thr = 0.05):
#     assert img.shape[0] == img.shape[1]
#     n_hil = 2
#     p_hil = np.ceil(np.log2(img.shape[0]))
#     square_size = (n_hil**p_hil).astype(int)
#     hilbert_curve = HilbertCurve(p_hil, n_hil)
#     img_edge = np.ones((square_size, square_size))
#     img_hilbert = np.zeros((square_size, square_size))

#     offset_x = 0
#     offset_y = 0
#     if img.shape[0] < square_size or img.shape[1] < square_size:
#         offset_y = int(np.floor((square_size - img.shape[0])/2))
#         offset_x = int(np.floor((square_size - img.shape[1])/2))
#     square_img = np.zeros(img_edge.shape)
#     square_img[offset_y:offset_y + img.shape[0], offset_x:offset_x + img.shape[1]] = img

#     previous_point = hilbert_curve.point_from_distance(0)
#     for point in hilbert_curve.points_from_distances(range(1, square_size**2)):
#         img_hilbert[point[0], point[1]] = np.abs(square_img[point[0], point[1]] - square_img[previous_point[0], previous_point[1]])
#         if(img_hilbert[point[0], point[1]] > edge_thr):
#             img_edge[point[0], point[1]] = 0
#         previous_point = point
#     return img_edge, 1 - img_hilbert


# # Genera una imagen a partir de la curva de Hilbert y una imagen a color
# def color_hilbert_img(img, edge_thr = 0.05):
#     assert img.shape[0] == img.shape[1]
#     n_hil = 2
#     p_hil = np.ceil(np.log2(img.shape[0]))
#     square_size = (n_hil**p_hil).astype(int)
#     hilbert_curve = HilbertCurve(p_hil, n_hil)
#     img_edge = np.ones((square_size, square_size))
#     img_hilbert = np.zeros((square_size, square_size))

#     offset_x = 0
#     offset_y = 0
#     if img.shape[0] < square_size or img.shape[1] < square_size:
#         offset_y = int(np.floor((square_size - img.shape[0])/2))
#         offset_x = int(np.floor((square_size - img.shape[1])/2))
#     if len(img) < 3:
#         square_img = np.zeros(img_edge.shape)
#     else:
#         square_img = np.zeros((square_size, square_size, 3))
#     square_img[offset_y:offset_y + img.shape[0], offset_x:offset_x + img.shape[1]] = img

#     previous_point = hilbert_curve.point_from_distance(0)
#     for point in hilbert_curve.points_from_distances(range(1, square_size**2)):
#         img_hilbert[point[0], point[1]] = np.linalg.norm(square_img[point[0], point[1]] - square_img[previous_point[0], previous_point[1]])
#         if(img_hilbert[point[0], point[1]] > edge_thr):
#             img_edge[point[0], point[1]] = 0
#         previous_point = point
#     return img_edge, 1 - img_hilbert


# # Genera una imagen considerando el contraste entre píxeles vecinos en una imagen en escala de grises
# def hf_img(img, hf_thr = 0.05):
#     assert img.shape[0] == img.shape[1]
#     n_hil = 2
#     p_hil = np.ceil(np.log2(img.shape[0]))
#     square_size = (n_hil**p_hil).astype(int)
#     img_edge = np.ones((square_size, square_size))
#     img_hf = np.ones((square_size, square_size))

#     offset_x = 0
#     offset_y = 0
#     if img.shape[0] < square_size or img.shape[1] < square_size:
#         offset_y = int(np.floor((square_size - img.shape[0])/2))
#         offset_x = int(np.floor((square_size - img.shape[1])/2))
#     square_img = np.zeros(img_edge.shape)
#     square_img[offset_y:offset_y + img.shape[0], offset_x:offset_x + img.shape[1]] = img

#     for i in range(1, square_size - 1):
#         for j in range(1, square_size - 1):
#             img_hf[i, j] = np.abs(img[i - 1, j] - img[i, j])
#             img_hf[i, j] += np.abs(img[i, j - 1] - img[i, j])
#             img_hf[i, j] += np.abs(img[i + 1, j] - img[i, j])
#             img_hf[i, j] += np.abs(img[i, j + 1] - img[i, j])
#             img_hf[i, j] /= 4
#             if(img_hf[i, j] > hf_thr):
#                 img_edge[i, j] = 0
#     return img_edge, 1 - img_hf

"""### Transformadas"""

# # Genera una imagen en base a la entropía parcial de una imagen en escala de grises
# def entropy_transform(img, kernel_size = 32, entropy_thr = 5, progress_bar = False):
#     assert img.shape[0] == img.shape[1]
#     assert kernel_size <= img.shape[0]

#     img_tr_size = img.shape[0] - kernel_size + 1
#     img_tr = np.zeros((img_tr_size, img_tr_size))
#     img_entropy = np.zeros((img_tr_size, img_tr_size))
#     bins = np.histogramdd([0, 1], bins = 256)[1]

#     if progress_bar:
#         iterator = tqdm(range(img_tr_size))
#     else:
#         iterator = range(img_tr_size)

#     for i in iterator:
#         for j in range(img_tr_size):
#             img_kernel = img[i:i + kernel_size, j:j + kernel_size]
#             density = np.histogramdd(np.ravel(img_kernel), bins = bins)[0]/img_kernel.size
#             density = list(filter(lambda p: p > 0, np.ravel(density)))
#             entropy = -np.sum(np.multiply(density, np.log2(density)))
#             img_entropy[i, j] = entropy
#             img_tr[i, j] = float(entropy > entropy_thr)

#     return img_tr, img_entropy

# # Genera una imagen en base a la entropía parcial de una imagen a color
# def color_entropy_transform(img, kernel_size = 32, entropy_thr = 3, progress_bar = False, bins = 10, ds = 2):
#     assert img.shape[0] == img.shape[1]
#     assert np.mod(img.shape[0], ds) == 0
#     assert kernel_size <= img.shape[0]

#     img_tr_size = int(img.shape[0]/ds)
#     img_tr = np.zeros((img_tr_size, img_tr_size))
#     img_entropy = np.zeros((img_tr_size, img_tr_size))
#     bins_color = np.histogramdd(np.array([[0, 0, 0], [256, 256, 256]]), bins = bins)[1]

#     if progress_bar:
#         iterator = tqdm(range(img_tr_size - int(np.ceil(kernel_size/ds))))
#     else:
#         iterator = range(img_tr_size - int(np.ceil(kernel_size/ds)))

#     for i in iterator:
#         for j in range(img_tr_size - int(np.ceil(kernel_size/ds))):
#             img_kernel = img[i*ds:i*ds + kernel_size, j*ds:j*ds + kernel_size]
#             img_reshaped = img_kernel[:, :].reshape(kernel_size**2, 3)
#             density = np.histogramdd(img_reshaped, bins = bins_color)[0]
#             density = np.array(list(filter(lambda p: p > 0, density.ravel())))/kernel_size**2
#             entropy = -np.sum(np.multiply(density, np.log2(density)))
#             img_entropy[i, j] = entropy
#             img_tr[i, j] = float(entropy > entropy_thr)

#     return img_tr, img_entropy


# # Genera una imagen en base a la varianza parcial de una imagen en escala de grises
# def var_transform(img, kernel_size = 32, var_thr = 0.1, progress_bar = False):
#     assert img.shape[0] == img.shape[1]
#     assert kernel_size <= img.shape[0]

#     img_tr_size = img.shape[0] - kernel_size + 1
#     img_tr = np.zeros((img_tr_size, img_tr_size))
#     img_var = np.zeros((img_tr_size, img_tr_size))

#     if progress_bar:
#         iterator = tqdm(range(img_tr_size))
#     else:
#         iterator = range(img_tr_size)

#     for i in iterator:
#         for j in range(img_tr_size):
#             img_kernel = img[i:i + kernel_size, j:j + kernel_size]
#             var = np.var(img_kernel)
#             img_var[i, j] = var
#             img_tr[i, j] = float(var > var_thr)

#     return img_tr, img_var


# # Genera una imagen en base a la media parcial de una imagen en escala de grises
# def mean_transform(img, kernel_size = 32, mean_thr = 0.1, progress_bar = False):
#     assert img.shape[0] == img.shape[1]
#     assert kernel_size <= img.shape[0]

#     img_tr_size = img.shape[0] - kernel_size + 1
#     img_tr = np.zeros((img_tr_size, img_tr_size))
#     img_mean = np.zeros((img_tr_size, img_tr_size))

#     if progress_bar:
#         iterator = tqdm(range(img_tr_size))
#     else:
#         iterator = range(img_tr_size)

#     for i in iterator:
#         for j in range(img_tr_size):
#             img_kernel = img[i:i + kernel_size, j:j + kernel_size]
#             mean = np.mean(img_kernel)
#             img_mean[i, j] = mean
#             img_tr[i, j] = float(mean < mean_thr)

#     return img_tr, img_mean

"""### Contorno"""

# # Marca el borde de la basura en el buffer
# def outline(garbage_img, img_source, widen_n = 4, offset_x = 0, offset_y = 0, color = 1):
#     garbage_img_edge = hilbert_img(garbage_img)[0]

#     widen_img = garbage_img_edge.copy()
#     for it in range(widen_n):
#         for i in range(1, garbage_img_edge.shape[0] - 1):
#             for j in range(1, garbage_img_edge.shape[1] - 1):
#                 if garbage_img_edge[i, j] == 0:
#                     widen_img[i - 1, j] = 0
#                     widen_img[i, j - 1] = 0
#                     widen_img[i + 1, j] = 0
#                     widen_img[i, j + 1] = 0
#         garbage_img_edge = widen_img.copy()

#     outline_img = img_source.copy()
#     border_index = (garbage_img_edge == 0).nonzero()
#     outline_img[border_index[0] + offset_y, border_index[1] + offset_x, np.ones(border_index[0].shape).astype(int)*color] = 1

#     return outline_img

"""# Pruebas en una misma imagen

## Imagen de prueba
"""

if 'img_source' not in globals():
    img_source = [img_acumar]
    img_buffer = [img_buffer_acumar]
    img_number = 0
else:
    img_number = 0 # cambiando este número se elige otra imagen

if img_source[img_number].shape[2] == 4:
    img_aux_color = rgba2rgb(img_source[img_number])
else:
    img_aux_color = img_source[img_number]
img_source_g = rgb2gray(img_aux_color)

if img_buffer[img_number].shape[2] == 4:
    img_aux_color = rgba2rgb(img_buffer[img_number])
else:
    img_aux_color = img_buffer[img_number]
img_buffer_bn = np.round(rgb2gray(img_aux_color))

img_buffer_outline = outline(img_buffer_bn, img_source[img_number])

total_rows = img_buffer_bn.shape[0]
total_columns = img_buffer_bn.shape[1]
buffer_start_row = np.min(np.where(img_buffer_bn == 1)[0]) # filas y columnas que limitan al buffer
buffer_end_row = np.max(np.where(img_buffer_bn == 1)[0]) # filas y columnas que limitan al buffer
buffer_start_column = np.min(np.where(np.matrix.transpose(img_buffer_bn) == 1)[0]) # filas y columnas que limitan al buffer
buffer_end_column = np.max(np.where(np.matrix.transpose(img_buffer_bn) == 1)[0]) # filas y columnas que limitan al buffer
index_margin = 50
index_img = [np.max([buffer_start_row - index_margin, 0]), np.min([total_rows, buffer_end_row + index_margin]),np.max([buffer_start_column - index_margin, 0]), np.min([total_columns, buffer_end_column + index_margin])]

# impresión en pantalla
plt.figure(figsize = (5.5, 3))

plt.subplot(1, 3, 1)
plt.imshow(img_source[img_number][index_img[0]:index_img[1], index_img[2]:index_img[3]])
plt.xticks([])
plt.yticks([])
plt.grid(False)
plt.box(False)

plt.subplot(1, 3, 2)
plt.imshow(img_buffer_bn[index_img[0]:index_img[1], index_img[2]:index_img[3]], cmap = 'gray', vmin = 0, vmax = 1)
plt.xticks([])
plt.yticks([])
plt.grid(False)
plt.box(False)

plt.subplot(1, 3, 3)
plt.imshow(img_buffer_outline[index_img[0]:index_img[1], index_img[2]:index_img[3]])
plt.xticks([])
plt.yticks([])
plt.grid(False)
plt.box(False)

"""## Preprocesamiento"""

# imagen obtenida con el filtro de Gabor
lam = 4 # lambda (longitud de onda)
pi_fraction = np.array(range(10))/10
angles = pi_fraction*np.pi
sigma = 2
sigma_x = sigma
sigma_y = sigma

gabor_kernels = [gabor_kernel(1/lam, theta = theta, sigma_x = sigma_x, sigma_y = sigma_y) for theta in angles]

img_gabor_g = np.zeros(img_source_g.shape)
for kernel in gabor_kernels:
    filtered_img = gabor_img(img_source_g, kernel)
    img_gabor_g += filtered_img

img_gabor_g /= len(gabor_kernels)

img_gabor_g = 1 - img_gabor_g

# imagen obtenida con el recorrido de Hilbert
edge_thr = 0.1 # bajar para detectar más basura
img_edge_bn, img_edge_g = hilbert_img(img_source_g, edge_thr)

"""## Transformadas"""

# parámetros del kernel para las transformadas
kernel_size = 32

# umbrales para la detección de basura
entropy_thr = 7 # bajar para detectar más basura
entropy_gabor_thr = 4.8 # bajar para detectar más basura
entropy_edge_thr = 0.9 # bajar para detectar más basura
mean_edge_thr = 0.9 # subir para detectar más basura

# imágenes transformadas
img_source_entropy_tr_bn, img_source_entropy_tr_g = entropy_transform(img_source_g, img_buffer_bn, kernel_size, entropy_thr, True)
img_gabor_entropy_tr_bn, img_gabor_entropy_tr_g = entropy_transform(img_gabor_g, img_buffer_bn, kernel_size, entropy_gabor_thr, True)
img_edge_entropy_tr_bn, img_edge_entropy_tr_g = entropy_transform(img_edge_bn, img_buffer_bn, kernel_size, entropy_edge_thr, True)
img_edge_mean_tr_bn, img_edge_mean_tr_g = mean_transform(img_edge_bn, img_buffer_bn, kernel_size, mean_edge_thr, True)

# borde de la basura detectada sobre la imagen original
img_source_entropy_outline = outline(img_source_entropy_tr_bn, img_source[img_number])
img_gabor_entropy_outline = outline(img_gabor_entropy_tr_bn, img_source[img_number])
img_edge_entropy_outline = outline(img_edge_entropy_tr_bn, img_source[img_number])
img_edge_mean_outline = outline(img_edge_mean_tr_bn, img_source[img_number])

"""## Impresión"""

# impresión en pantalla
plt.figure(figsize = (5.5, 3))
# plt.figure(figsize = (2, 2)) individuales para el informe

plt.subplot(3, 4, 1)
plt.imshow(img_source_g[index_img[0]:index_img[1], index_img[2]:index_img[3]], cmap = 'gray', vmin = 0, vmax = 1)
plt.xticks([])
plt.yticks([])
plt.grid(False)
plt.box(False)

plt.subplot(3, 4, 2)
plt.imshow(img_gabor_g[index_img[0]:index_img[1], index_img[2]:index_img[3]], cmap = 'gray', vmin = 0, vmax = 1) # por qué 1 - ?
plt.xticks([])
plt.yticks([])
plt.grid(False)
plt.box(False)

plt.subplot(3, 4, 3)
plt.imshow(img_edge_bn[index_img[0]:index_img[1], index_img[2]:index_img[3]], cmap ='gray', vmin = 0, vmax = 1)
plt.xticks([])
plt.yticks([])
plt.grid(False)
plt.box(False)

plt.subplot(3, 4, 4)
plt.imshow(img_edge_bn[index_img[0]:index_img[1], index_img[2]:index_img[3]], cmap = 'gray', vmin = 0, vmax = 1)
plt.xticks([])
plt.yticks([])
plt.grid(False)
plt.box(False)

plt.subplot(3, 4, 5)
plt.imshow(img_source_entropy_tr_bn[index_img[0]:index_img[1], index_img[2]:index_img[3]], cmap = 'gray', vmin = 0, vmax = 1)
plt.xticks([])
plt.yticks([])
plt.grid(False)
plt.box(False)

plt.subplot(3, 4, 6)
plt.imshow(img_gabor_entropy_tr_bn[index_img[0]:index_img[1], index_img[2]:index_img[3]], cmap = 'gray', vmin = 0, vmax = 1)
plt.xticks([])
plt.yticks([])
plt.grid(False)
plt.box(False)

plt.subplot(3, 4, 7)
plt.imshow(img_edge_entropy_tr_bn[index_img[0]:index_img[1], index_img[2]:index_img[3]], cmap = 'gray', vmin = 0, vmax = 1)
plt.xticks([])
plt.yticks([])
plt.grid(False)
plt.box(False)

plt.subplot(3, 4, 8)
plt.imshow(img_edge_mean_tr_bn[index_img[0]:index_img[1], index_img[2]:index_img[3]], cmap = 'gray', vmin = 0, vmax = 1)
plt.xticks([])
plt.yticks([])
plt.grid(False)
plt.box(False)

plt.subplot(3, 4, 9)
plt.imshow(img_source_entropy_outline[index_img[0]:index_img[1], index_img[2]:index_img[3]])
plt.xticks([])
plt.yticks([])
plt.grid(False)
plt.box(False)

plt.subplot(3, 4, 10)
plt.imshow(img_gabor_entropy_outline[index_img[0]:index_img[1], index_img[2]:index_img[3]])
plt.xticks([])
plt.yticks([])
plt.grid(False)
plt.box(False)

plt.subplot(3, 4, 11)
plt.imshow(img_edge_entropy_outline[index_img[0]:index_img[1], index_img[2]:index_img[3]])
plt.xticks([])
plt.yticks([])
plt.grid(False)
plt.box(False)

plt.subplot(3, 4, 12)
plt.imshow(img_edge_mean_outline[index_img[0]:index_img[1], index_img[2]:index_img[3]])
plt.xticks([])
plt.yticks([])
plt.grid(False)
plt.box(False)
plt.show()

"""## Cálculo de la superficie"""

img_tr = [img_source_entropy_tr_bn, img_gabor_entropy_tr_bn, img_edge_entropy_tr_bn, img_edge_mean_tr_bn]

proyection_map = np.zeros(img_buffer_bn.shape) # matriz de ponderación del buffer

h_cam = 3 # altura de la cámara

gamma_h = np.deg2rad(70) # ángulo de visión de la cámara
delta_alpha_h = gamma_h/total_columns # ángulo por píxel

# gamma_v/2 tiene que ser < min(theta) o se tiene que limitar la imagen según buffer_start_row
gamma_v = gamma_h*total_rows/total_columns # ángulo de visión de la cámara # definirlo como gamma_col*total_rows/total_columns
phi = np.deg2rad(35) # posición de la cámara
delta_alpha_v = gamma_v/total_rows # ángulo por píxel

n_cam = np.array([-np.sin(phi), 0, np.cos(phi)])
n_wat = np.array([0, 0, 1])

for i in tqdm(range(buffer_start_row, total_rows)):
    alpha_v = -gamma_v/2 + (total_rows - i)*delta_alpha_v
    for j in range(total_columns):
        alpha_h = -gamma_h/2 + j*delta_alpha_h
        n_theta = np.array([np.sin(alpha_h), np.cos(alpha_h), 0])
        theta = np.arccos(np.dot(np.cross(n_wat, n_theta), np.cross(n_cam, n_theta))/(np.linalg.norm(np.cross(n_wat, n_theta))*np.linalg.norm(np.cross(n_cam, n_theta))))
        
        r = np.abs((np.sin(theta) + np.tan(np.deg2rad(90) + alpha_v - theta)*np.cos(theta))*h_cam)
        delta_r = np.abs(np.abs((np.sin(theta) + np.tan(np.deg2rad(90) + alpha_v + delta_alpha_v - theta)*np.cos(theta))*h_cam) - r)
        proyection_map[i, j] = delta_r*r*delta_alpha_h

# nivel de llenado del buffer para cada imagen
b = []
for tri in img_tr:
    b.append(np.sum(img_buffer_bn*proyection_map*tri)/np.sum(img_buffer_bn*proyection_map)*100)

print(b)

plt.figure(figsize = (2, 2))
plt.imshow(proyection_map[index_img[0]:index_img[1], index_img[2]:index_img[3]], cmap = 'gray', vmin = 0, vmax = np.max(proyection_map[buffer_start_row:, :]))
plt.xticks([])
plt.yticks([])
plt.grid(False)
plt.box(False)

"""# Pruebas en imágenes individuales

## Imágenes de prueba
"""
'''
img_number = 29

if img_source[img_number].shape[2] == 4:
    img_aux_color = rgba2rgb(img_source[img_number])
else:
    img_aux_color = img_source[img_number]
img_source_g = rgb2gray(img_aux_color)

if img_buffer[img_number].shape[2] == 4:
    img_aux_color = rgba2rgb(img_buffer[img_number])
else:
    img_aux_color = img_buffer[img_number]
img_buffer_bn = np.round(rgb2gray(img_aux_color))

img_buffer_outline = outline(img_buffer_bn, img_source[img_number])

total_rows = img_buffer_bn.shape[0]
total_columns = img_buffer_bn.shape[1]
buffer_start_row = np.min(np.where(img_buffer_bn == 1)[0]) # filas y columnas que limitan al buffer
buffer_end_row = np.max(np.where(img_buffer_bn == 1)[0]) # filas y columnas que limitan al buffer
buffer_start_column = np.min(np.where(np.matrix.transpose(img_buffer_bn) == 1)[0]) # filas y columnas que limitan al buffer
buffer_end_column = np.max(np.where(np.matrix.transpose(img_buffer_bn) == 1)[0]) # filas y columnas que limitan al buffer
index_margin = 50
index_img = [np.max([buffer_start_row - index_margin, 0]), np.min([total_rows, buffer_end_row + index_margin]),np.max([buffer_start_column - index_margin, 0]), np.min([total_columns, buffer_end_column + index_margin])]

# impresión en pantalla
plt.figure(figsize = (5.5, 3))

plt.subplot(1, 3, 1)
plt.imshow(img_source[img_number][index_img[0]:index_img[1], index_img[2]:index_img[3]])
plt.xticks([])
plt.yticks([])
plt.grid(False)
plt.box(False)

plt.subplot(1, 3, 2)
plt.imshow(img_buffer_bn, cmap = 'gray', vmin = 0, vmax = 1)
plt.xticks([])
plt.yticks([])
plt.grid(False)
plt.box(False)

plt.subplot(1, 3, 3)
plt.imshow(img_buffer_outline[index_img[0]:index_img[1], index_img[2]:index_img[3]])
plt.xticks([])
plt.yticks([])
plt.grid(False)
plt.box(False)
'''
"""## Parámetros"""

edge_thr = [0.1, 0.07, 0.04, 0.04, 0.04, 0.05, 0.04, 0.04, 0.04, 0.05, 0.05, 0.05, 0.05, 0.05, 0.04, 0.05, 0.02, 0.05, 0.04, 0.04, 0.04, 0.04, 0.04, 0.04, 0.03, 0.03, 0.03, 0.035, 0.035, 0.12, 0.12]
kernel_size = [32, 32, 32, 32, 32, 32, 100, 32, 64, 32, 32, 32, 32, 32, 64, 32, 100, 50, 32, 32, 32, 32, 32, 32, 32, 32, 32, 64, 64, 40, 40]
mean_edge_thr = [0.7, 0.85, 0.85, 0.85, 0.85, 0.85, 0.7, 0.85, 0.7, 0.8, 0.8, 0.8, 0.8, 0.8, 0.65, 0.7, 0.5, 0.75, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.8, 0.8, 0.75, 0.75]


'''
edge_thr[img_number] = 0.12 # bajar para detectar más basura
kernel_size[img_number] = 40
mean_edge_thr[img_number] = 0.75 # subir para detectar más basura

"""## Resultados"""

for img_number in tqdm(range(img_total_number)):
  if img_source[img_number].shape[2] == 4:
      img_aux_color = rgba2rgb(img_source[img_number])
  else:
      img_aux_color = img_source[img_number]
  img_source_g = rgb2gray(img_aux_color)

  if img_buffer[img_number].shape[2] == 4:
      img_aux_color = rgba2rgb(img_buffer[img_number])
  else:
      img_aux_color = img_buffer[img_number]
  img_buffer_bn = np.round(rgb2gray(img_aux_color))

#   img_buffer_outline = outline(img_buffer_bn, img_source[img_number])

  total_rows = img_buffer_bn.shape[0]
  total_columns = img_buffer_bn.shape[1]
  buffer_start_row = np.min(np.where(img_buffer_bn == 1)[0]) # filas y columnas que limitan al buffer
  buffer_end_row = np.max(np.where(img_buffer_bn == 1)[0]) # filas y columnas que limitan al buffer
  buffer_start_column = np.min(np.where(np.matrix.transpose(img_buffer_bn) == 1)[0]) # filas y columnas que limitan al buffer
  buffer_end_column = np.max(np.where(np.matrix.transpose(img_buffer_bn) == 1)[0]) # filas y columnas que limitan al buffer
  index_margin = 50
  index_img = [np.max([buffer_start_row - index_margin, 0]), np.min([total_rows, buffer_end_row + index_margin]),np.max([buffer_start_column - index_margin, 0]), np.min([total_columns, buffer_end_column + index_margin])]


  # img_source_gp = img_source_g/(np.percentile(img_source_g,0.95) - np.percentile(img_source_g,0.05))
#   img_edge_bn, img_edge_g = hilbert_img(img_source_g, edge_thr[img_number])
#   img_edge_mean_tr_bn, img_edge_mean_tr_g = mean_transform(img_edge_bn, img_buffer_bn, kernel_size[img_number], mean_edge_thr[img_number], False)
#   img_edge_mean_outline = outline(img_edge_mean_tr_bn, img_source[img_number])

  # impresión en pantalla
  # plt.figure(figsize = (5.5, 3))

  # plt.subplot(1, 3, 1)
  # plt.imshow(img_edge_bn[index_img[0]:index_img[1], index_img[2]:index_img[3]], cmap = 'gray', vmin = 0, vmax = 1)
  # plt.xticks([])
  # plt.yticks([])
  # plt.grid(False)
  # plt.box(False)

  # plt.subplot(1, 3, 2)
  # plt.imshow(img_edge_mean_tr_bn[index_img[0]:index_img[1], index_img[2]:index_img[3]], cmap = 'gray', vmin = 0, vmax = 1)
  # plt.xticks([])
  # plt.yticks([])
  # plt.grid(False)
  # plt.box(False)

  plt.figure(figsize=plt.figaspect(img_source[img_number][index_img[0]:index_img[1], index_img[2]:index_img[3]]))
  name = '00' if img_number <= 9 else '0'
  plt.imshow(img_source[img_number][index_img[0]:index_img[1], index_img[2]:index_img[3]])
  plt.subplots_adjust(0, 0, 1, 1)
  plt.xticks([])
  plt.yticks([])
  plt.grid(False)
  plt.box(False)
  #plt.savefig(images_dir + '/recortada_' + name + img_number + '.png')
  plt.close()

  
  # plt.figure(figsize=plt.figaspect(img_edge_mean_tr_bn[index_img[0]:index_img[1], index_img[2]:index_img[3]]))
  # # name = '00' if img_number <= 9 else '0'
  # plt.imshow(img_edge_mean_tr_bn[index_img[0]:index_img[1], index_img[2]:index_img[3]], cmap = 'gray', vmin = 0, vmax = 1)
  # plt.subplots_adjust(0, 0, 1, 1)
  # plt.xticks([])
  # plt.yticks([])
  # plt.grid(False)
  # plt.box(False)
  # plt.savefig(images_dir + '/procesada_bn_' + name + img_number + '.png')



#   plt.figure(figsize=plt.figaspect(img_edge_mean_outline[index_img[0]:index_img[1], index_img[2]:index_img[3]]))
  # plt.subplot(1, 3, 3)
  # name = '00' if img_number <= 9 else '0'
#   plt.imshow(img_edge_mean_outline[index_img[0]:index_img[1], index_img[2]:index_img[3]])
#   plt.subplots_adjust(0, 0, 1, 1)
#   plt.xticks([])
#   plt.yticks([])
#   plt.grid(False)
#   plt.box(False)
#   plt.savefig(images_dir + '/procesada_' + name + img_number + '.png')
  # print(np.sum(img_buffer_bn*img_edge_mean_tr_bn)/np.sum(img_buffer_bn)*100)
  '''